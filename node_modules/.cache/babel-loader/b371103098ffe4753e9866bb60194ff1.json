{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Point} Point\n */\n\n/**\n * @typedef {Record<string, unknown>} StackState\n * @typedef {[Construct, StackState]} StackItem\n */\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\nimport { splice } from 'micromark-util-chunked';\n/** @type {InitialConstruct} */\n\nexport var document = {\n  tokenize: initializeDocument\n};\n/** @type {Construct} */\n\nvar containerConstruct = {\n  tokenize: tokenizeContainer\n};\n/** @type {Initializer} */\n\nfunction initializeDocument(effects) {\n  var self = this;\n  /** @type {StackItem[]} */\n\n  var stack = [];\n  var continued = 0;\n  /** @type {TokenizeContext|undefined} */\n\n  var childFlow;\n  /** @type {Token|undefined} */\n\n  var childToken;\n  /** @type {number} */\n\n  var lineStartOffset;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // First we iterate through the open blocks, starting with the root\n    // document, and descending through last children down to the last open\n    // block.\n    // Each block imposes a condition that the line must satisfy if the block is\n    // to remain open.\n    // For example, a block quote requires a `>` character.\n    // A paragraph requires a non-blank line.\n    // In this phase we may match all or just some of the open blocks.\n    // But we cannot close unmatched blocks yet, because we may have a lazy\n    // continuation line.\n    if (continued < stack.length) {\n      var item = stack[continued];\n      self.containerState = item[1];\n      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code);\n    } // Done.\n\n\n    return checkNewContainers(code);\n  }\n  /** @type {State} */\n\n\n  function documentContinue(code) {\n    if (self.containerState._closeFlow) closeFlow();\n    continued++;\n    return start(code);\n  }\n  /** @type {State} */\n\n\n  function checkNewContainers(code) {\n    // Next, after consuming the continuation markers for existing blocks, we\n    // look for new block starts (e.g. `>` for a block quote).\n    // If we encounter a new block start, we close any blocks unmatched in\n    // step 1 before creating the new block as a child of the last matched\n    // block.\n    if (continued === stack.length) {\n      // No need to `check` whether there’s a container, of `exitContainers`\n      // would be moot.\n      // We can instead immediately `attempt` to parse one.\n      if (!childFlow) {\n        return documentContinued(code);\n      } // If we have concrete content, such as block HTML or fenced code,\n      // we can’t have containers “pierce” into them, so we can immediately\n      // start.\n\n\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        return flowStart(code);\n      } // If we do have flow, it could still be a blank line,\n      // but we’d be interrupting it w/ a new container if there’s a current\n      // construct.\n\n\n      self.interrupt = Boolean(childFlow.currentConstruct);\n    } // Check if there is a new container.\n\n\n    self.containerState = {};\n    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code);\n  }\n  /** @type {State} */\n\n\n  function thereIsANewContainer(code) {\n    if (childFlow) closeFlow();\n    exitContainers(continued);\n    return documentContinued(code);\n  }\n  /** @type {State} */\n\n\n  function thereIsNoNewContainer(code) {\n    self.parser.lazy[self.now().line] = continued !== stack.length;\n    lineStartOffset = self.now().offset;\n    return flowStart(code);\n  }\n  /** @type {State} */\n\n\n  function documentContinued(code) {\n    // Try new containers.\n    self.containerState = {};\n    return effects.attempt(containerConstruct, containerContinue, flowStart)(code);\n  }\n  /** @type {State} */\n\n\n  function containerContinue(code) {\n    continued++;\n    stack.push([self.currentConstruct, self.containerState]); // Try another.\n\n    return documentContinued(code);\n  }\n  /** @type {State} */\n\n\n  function flowStart(code) {\n    if (code === null) {\n      if (childFlow) closeFlow();\n      exitContainers(0);\n      effects.consume(code);\n      return;\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now());\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    });\n    return flowContinue(code);\n  }\n  /** @type {State} */\n\n\n  function flowContinue(code) {\n    if (code === null) {\n      writeToChild(effects.exit('chunkFlow'), true);\n      exitContainers(0);\n      effects.consume(code);\n      return;\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code);\n      writeToChild(effects.exit('chunkFlow')); // Get ready for the next line.\n\n      continued = 0;\n      self.interrupt = undefined;\n      return start;\n    }\n\n    effects.consume(code);\n    return flowContinue;\n  }\n  /**\n   * @param {Token} token\n   * @param {boolean} [eof]\n   * @returns {void}\n   */\n\n\n  function writeToChild(token, eof) {\n    var stream = self.sliceStream(token);\n    if (eof) stream.push(null);\n    token.previous = childToken;\n    if (childToken) childToken.next = token;\n    childToken = token;\n    childFlow.defineSkip(token.start);\n    childFlow.write(stream); // Alright, so we just added a lazy line:\n    //\n    // ```markdown\n    // > a\n    // b.\n    //\n    // Or:\n    //\n    // > ~~~c\n    // d\n    //\n    // Or:\n    //\n    // > | e |\n    // f\n    // ```\n    //\n    // The construct in the second example (fenced code) does not accept lazy\n    // lines, so it marked itself as done at the end of its first line, and\n    // then the content construct parses `d`.\n    // Most constructs in markdown match on the first line: if the first line\n    // forms a construct, a non-lazy line can’t “unmake” it.\n    //\n    // The construct in the third example is potentially a GFM table, and\n    // those are *weird*.\n    // It *could* be a table, from the first line, if the following line\n    // matches a condition.\n    // In this case, that second line is lazy, which “unmakes” the first line\n    // and turns the whole into one content block.\n    //\n    // We’ve now parsed the non-lazy and the lazy line, and can figure out\n    // whether the lazy line started a new flow block.\n    // If it did, we exit the current containers between the two flow blocks.\n\n    if (self.parser.lazy[token.start.line]) {\n      var index = childFlow.events.length;\n\n      while (index--) {\n        if ( // The token starts before the line ending…\n        childFlow.events[index][1].start.offset < lineStartOffset && (!childFlow.events[index][1].end || // …or ends after it.\n        childFlow.events[index][1].end.offset > lineStartOffset)) {\n          // Exit: there’s still something open, which means it’s a lazy line\n          // part of something.\n          return;\n        }\n      }\n\n      var indexBeforeExits = self.events.length;\n      var indexBeforeFlow = indexBeforeExits;\n      /** @type {boolean|undefined} */\n\n      var seen;\n      /** @type {Point|undefined} */\n\n      var point; // Find the previous chunk (the one before the lazy line).\n\n      while (indexBeforeFlow--) {\n        if (self.events[indexBeforeFlow][0] === 'exit' && self.events[indexBeforeFlow][1].type === 'chunkFlow') {\n          if (seen) {\n            point = self.events[indexBeforeFlow][1].end;\n            break;\n          }\n\n          seen = true;\n        }\n      }\n\n      exitContainers(continued); // Fix positions.\n\n      index = indexBeforeExits;\n\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point);\n        index++;\n      } // Inject the exits earlier (they’re still also at the end).\n\n\n      splice(self.events, indexBeforeFlow + 1, 0, self.events.slice(indexBeforeExits)); // Discard the duplicate exits.\n\n      self.events.length = index;\n    }\n  }\n  /**\n   * @param {number} size\n   * @returns {void}\n   */\n\n\n  function exitContainers(size) {\n    var index = stack.length; // Exit open containers.\n\n    while (index-- > size) {\n      var entry = stack[index];\n      self.containerState = entry[1];\n      entry[0].exit.call(self, effects);\n    }\n\n    stack.length = size;\n  }\n\n  function closeFlow() {\n    childFlow.write([null]);\n    childToken = undefined;\n    childFlow = undefined;\n    self.containerState._closeFlow = undefined;\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeContainer(effects, ok, nok) {\n  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok, nok), 'linePrefix', this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n}","map":{"version":3,"sources":["E:/projects/localtalk.mobi/mobilechat-adminpanel/node_modules/micromark/lib/initialize/document.js"],"names":["factorySpace","markdownLineEnding","splice","document","tokenize","initializeDocument","containerConstruct","tokenizeContainer","effects","self","stack","continued","childFlow","childToken","lineStartOffset","start","code","length","item","containerState","attempt","continuation","documentContinue","checkNewContainers","_closeFlow","closeFlow","documentContinued","currentConstruct","concrete","flowStart","interrupt","Boolean","check","thereIsANewContainer","thereIsNoNewContainer","exitContainers","parser","lazy","now","line","offset","containerContinue","push","consume","flow","enter","contentType","previous","_tokenizer","flowContinue","writeToChild","exit","undefined","token","eof","stream","sliceStream","next","defineSkip","write","index","events","end","indexBeforeExits","indexBeforeFlow","seen","point","type","Object","assign","slice","size","entry","call","ok","nok","constructs","disable","null","includes"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Point} Point\n */\n\n/**\n * @typedef {Record<string, unknown>} StackState\n * @typedef {[Construct, StackState]} StackItem\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n/** @type {InitialConstruct} */\n\nexport const document = {\n  tokenize: initializeDocument\n}\n/** @type {Construct} */\n\nconst containerConstruct = {\n  tokenize: tokenizeContainer\n}\n/** @type {Initializer} */\n\nfunction initializeDocument(effects) {\n  const self = this\n  /** @type {StackItem[]} */\n\n  const stack = []\n  let continued = 0\n  /** @type {TokenizeContext|undefined} */\n\n  let childFlow\n  /** @type {Token|undefined} */\n\n  let childToken\n  /** @type {number} */\n\n  let lineStartOffset\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // First we iterate through the open blocks, starting with the root\n    // document, and descending through last children down to the last open\n    // block.\n    // Each block imposes a condition that the line must satisfy if the block is\n    // to remain open.\n    // For example, a block quote requires a `>` character.\n    // A paragraph requires a non-blank line.\n    // In this phase we may match all or just some of the open blocks.\n    // But we cannot close unmatched blocks yet, because we may have a lazy\n    // continuation line.\n    if (continued < stack.length) {\n      const item = stack[continued]\n      self.containerState = item[1]\n      return effects.attempt(\n        item[0].continuation,\n        documentContinue,\n        checkNewContainers\n      )(code)\n    } // Done.\n\n    return checkNewContainers(code)\n  }\n  /** @type {State} */\n\n  function documentContinue(code) {\n    if (self.containerState._closeFlow) closeFlow()\n    continued++\n    return start(code)\n  }\n  /** @type {State} */\n\n  function checkNewContainers(code) {\n    // Next, after consuming the continuation markers for existing blocks, we\n    // look for new block starts (e.g. `>` for a block quote).\n    // If we encounter a new block start, we close any blocks unmatched in\n    // step 1 before creating the new block as a child of the last matched\n    // block.\n    if (continued === stack.length) {\n      // No need to `check` whether there’s a container, of `exitContainers`\n      // would be moot.\n      // We can instead immediately `attempt` to parse one.\n      if (!childFlow) {\n        return documentContinued(code)\n      } // If we have concrete content, such as block HTML or fenced code,\n      // we can’t have containers “pierce” into them, so we can immediately\n      // start.\n\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        return flowStart(code)\n      } // If we do have flow, it could still be a blank line,\n      // but we’d be interrupting it w/ a new container if there’s a current\n      // construct.\n\n      self.interrupt = Boolean(childFlow.currentConstruct)\n    } // Check if there is a new container.\n\n    self.containerState = {}\n    return effects.check(\n      containerConstruct,\n      thereIsANewContainer,\n      thereIsNoNewContainer\n    )(code)\n  }\n  /** @type {State} */\n\n  function thereIsANewContainer(code) {\n    if (childFlow) closeFlow()\n    exitContainers(continued)\n    return documentContinued(code)\n  }\n  /** @type {State} */\n\n  function thereIsNoNewContainer(code) {\n    self.parser.lazy[self.now().line] = continued !== stack.length\n    lineStartOffset = self.now().offset\n    return flowStart(code)\n  }\n  /** @type {State} */\n\n  function documentContinued(code) {\n    // Try new containers.\n    self.containerState = {}\n    return effects.attempt(\n      containerConstruct,\n      containerContinue,\n      flowStart\n    )(code)\n  }\n  /** @type {State} */\n\n  function containerContinue(code) {\n    continued++\n    stack.push([self.currentConstruct, self.containerState]) // Try another.\n\n    return documentContinued(code)\n  }\n  /** @type {State} */\n\n  function flowStart(code) {\n    if (code === null) {\n      if (childFlow) closeFlow()\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now())\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    })\n    return flowContinue(code)\n  }\n  /** @type {State} */\n\n  function flowContinue(code) {\n    if (code === null) {\n      writeToChild(effects.exit('chunkFlow'), true)\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      writeToChild(effects.exit('chunkFlow')) // Get ready for the next line.\n\n      continued = 0\n      self.interrupt = undefined\n      return start\n    }\n\n    effects.consume(code)\n    return flowContinue\n  }\n  /**\n   * @param {Token} token\n   * @param {boolean} [eof]\n   * @returns {void}\n   */\n\n  function writeToChild(token, eof) {\n    const stream = self.sliceStream(token)\n    if (eof) stream.push(null)\n    token.previous = childToken\n    if (childToken) childToken.next = token\n    childToken = token\n    childFlow.defineSkip(token.start)\n    childFlow.write(stream) // Alright, so we just added a lazy line:\n    //\n    // ```markdown\n    // > a\n    // b.\n    //\n    // Or:\n    //\n    // > ~~~c\n    // d\n    //\n    // Or:\n    //\n    // > | e |\n    // f\n    // ```\n    //\n    // The construct in the second example (fenced code) does not accept lazy\n    // lines, so it marked itself as done at the end of its first line, and\n    // then the content construct parses `d`.\n    // Most constructs in markdown match on the first line: if the first line\n    // forms a construct, a non-lazy line can’t “unmake” it.\n    //\n    // The construct in the third example is potentially a GFM table, and\n    // those are *weird*.\n    // It *could* be a table, from the first line, if the following line\n    // matches a condition.\n    // In this case, that second line is lazy, which “unmakes” the first line\n    // and turns the whole into one content block.\n    //\n    // We’ve now parsed the non-lazy and the lazy line, and can figure out\n    // whether the lazy line started a new flow block.\n    // If it did, we exit the current containers between the two flow blocks.\n\n    if (self.parser.lazy[token.start.line]) {\n      let index = childFlow.events.length\n\n      while (index--) {\n        if (\n          // The token starts before the line ending…\n          childFlow.events[index][1].start.offset < lineStartOffset &&\n          (!childFlow.events[index][1].end || // …or ends after it.\n            childFlow.events[index][1].end.offset > lineStartOffset)\n        ) {\n          // Exit: there’s still something open, which means it’s a lazy line\n          // part of something.\n          return\n        }\n      }\n\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {boolean|undefined} */\n\n      let seen\n      /** @type {Point|undefined} */\n\n      let point // Find the previous chunk (the one before the lazy line).\n\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === 'chunkFlow'\n        ) {\n          if (seen) {\n            point = self.events[indexBeforeFlow][1].end\n            break\n          }\n\n          seen = true\n        }\n      }\n\n      exitContainers(continued) // Fix positions.\n\n      index = indexBeforeExits\n\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point)\n        index++\n      } // Inject the exits earlier (they’re still also at the end).\n\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      ) // Discard the duplicate exits.\n\n      self.events.length = index\n    }\n  }\n  /**\n   * @param {number} size\n   * @returns {void}\n   */\n\n  function exitContainers(size) {\n    let index = stack.length // Exit open containers.\n\n    while (index-- > size) {\n      const entry = stack[index]\n      self.containerState = entry[1]\n      entry[0].exit.call(self, effects)\n    }\n\n    stack.length = size\n  }\n\n  function closeFlow() {\n    childFlow.write([null])\n    childToken = undefined\n    childFlow = undefined\n    self.containerState._closeFlow = undefined\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeContainer(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(this.parser.constructs.document, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4\n  )\n}\n"]},"metadata":{},"sourceType":"module"}