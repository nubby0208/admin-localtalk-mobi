{"ast":null,"code":"/**\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('highlight.js').HighlightResult} HighlightResult\n * @typedef {import('highlight.js').HLJSOptions} HighlightOptions\n * @typedef {import('highlight.js').LanguageFn} HighlightSyntax\n * @typedef {import('highlight.js').Emitter} HighlightEmitter\n *\n * @typedef {{type: 'element', tagName: 'span', properties: {className: Array.<string>}, children: Array.<LowlightElementSpan|Text>}} LowlightElementSpan\n * @typedef {{type: 'root', data: {language: string, relevance: number}, children: Array.<LowlightElementSpan|Text>}} LowlightRoot\n *\n * @typedef {Object} ExtraAutoOptions\n * @property {Array.<string>} [subset] List of allowed languages; defaults to all registered languages\n *\n * @typedef {Object} LowlightOptions\n * @property {string} [prefix='hljs-'] Class prefix\n *\n * @typedef {LowlightOptions & ExtraAutoOptions} LowlightAutoOptions\n */\nimport high from 'highlight.js/lib/core';\nimport { fault } from 'fault';\nconst own = {}.hasOwnProperty;\nconst defaultPrefix = 'hljs-';\n/**\n * Parse `value` (code) according to the `language` (name) grammar.\n *\n * @param {string} language Language name\n * @param {string} value Code value\n * @param {LowlightOptions} [options={}] Settings\n * @returns {LowlightRoot}\n */\n\nfunction highlight(language, value, options = {}) {\n  let prefix = options.prefix;\n\n  if (typeof language !== 'string') {\n    throw fault('Expected `string` for name, got `%s`', language);\n  }\n\n  if (!high.getLanguage(language)) {\n    throw fault('Unknown language: `%s` is not registered', language);\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value);\n  }\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix;\n  }\n\n  high.configure({\n    __emitter: HastEmitter,\n    classPrefix: prefix\n  });\n  /** @type {HighlightResult & {_emitter: HastEmitter}} */\n  // @ts-ignore our emitter is added.\n\n  const result = high.highlight(value, {\n    language,\n    ignoreIllegals: true\n  });\n  high.configure({}); // Highlight.js seems to use this (currently) for broken grammars, so let’s\n  // keep it in there just to be sure.\n\n  /* c8 ignore next 3 */\n\n  if (result.errorRaised) {\n    throw result.errorRaised;\n  }\n\n  result._emitter.root.data.language = result.language;\n  result._emitter.root.data.relevance = result.relevance;\n  return result._emitter.root;\n}\n/**\n * Parse `value` (code) by guessing its grammar.\n *\n * @param {string} value Code value\n * @param {LowlightAutoOptions} [options={}] Settings\n * @returns {LowlightRoot}\n */\n\n\nfunction highlightAuto(value, options = {}) {\n  const subset = options.subset || high.listLanguages();\n  let prefix = options.prefix;\n  let index = -1;\n  /** @type {LowlightRoot} */\n\n  let result = {\n    type: 'root',\n    data: {\n      language: null,\n      relevance: 0\n    },\n    children: []\n  };\n  /** @type {string} */\n\n  let name;\n  /** @type {LowlightRoot} */\n\n  let current;\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix;\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value);\n  }\n\n  while (++index < subset.length) {\n    name = subset[index];\n    if (!high.getLanguage(name)) continue;\n    current = highlight(name, value, options);\n    if (current.data.relevance > result.data.relevance) result = current;\n  }\n\n  return result;\n}\n/**\n * Register a language.\n *\n * @param {string} language Language name\n * @param {HighlightSyntax} syntax Language syntax\n * @returns {void}\n */\n\n\nfunction registerLanguage(language, syntax) {\n  high.registerLanguage(language, syntax);\n}\n/**\n * Get a list of all registered languages.\n *\n * @returns {Array.<string>}\n */\n\n\nfunction listLanguages() {\n  return high.listLanguages();\n}\n\nconst registerAlias =\n/**\n * Register more aliases for an already registered language.\n *\n * @param {string|Object<string, string|Array.<string>>} language\n * @param {string|Array.<string>} [alias]\n * @returns {void}\n */\nfunction (language, alias) {\n  /** @type {Object<string, string|Array.<string>>} */\n  let map;\n  /** @type {string} */\n\n  let key;\n\n  if (typeof language === 'string') {\n    map = {};\n    map[language] = alias;\n  } else {\n    map = language;\n  }\n\n  for (key in map) {\n    if (own.call(map, key)) {\n      high.registerAliases(map[key], {\n        languageName: key\n      });\n    }\n  }\n};\n/** @type {HighlightEmitter} */\n\n\nclass HastEmitter {\n  /**\n   * @param {HighlightOptions} options\n   */\n  constructor(options) {\n    /** @type {HighlightOptions} */\n    this.options = options;\n    /** @type {LowlightRoot} */\n\n    this.root = {\n      type: 'root',\n      data: {\n        language: undefined,\n        relevance: 0\n      },\n      children: []\n    };\n    /** @type {[LowlightRoot, ...LowlightElementSpan[]]} */\n\n    this.stack = [this.root];\n  }\n  /**\n   * @param {string} value\n   */\n\n\n  addText(value) {\n    if (value === '') return;\n    const current = this.stack[this.stack.length - 1];\n    const tail = current.children[current.children.length - 1];\n\n    if (tail && tail.type === 'text') {\n      tail.value += value;\n    } else {\n      current.children.push({\n        type: 'text',\n        value\n      });\n    }\n  }\n  /**\n   * @param {string} value\n   * @param {string} name\n   */\n\n\n  addKeyword(value, name) {\n    this.openNode(name);\n    this.addText(value);\n    this.closeNode();\n  }\n  /**\n   * @param {HastEmitter} other\n   * @param {string} name\n   */\n\n\n  addSublanguage(other, name) {\n    const current = this.stack[this.stack.length - 1];\n    const results = other.root.children;\n\n    if (name) {\n      current.children.push({\n        type: 'element',\n        tagName: 'span',\n        properties: {\n          className: [name]\n        },\n        children: results\n      });\n    } else {\n      current.children.push(...results);\n    }\n  }\n  /**\n   * @param {string} name\n   */\n\n\n  openNode(name) {\n    const className = name.split('.').map(d => this.options.classPrefix + d);\n    const current = this.stack[this.stack.length - 1];\n    /** @type {LowlightElementSpan} */\n\n    const child = {\n      type: 'element',\n      tagName: 'span',\n      properties: {\n        className\n      },\n      children: []\n    };\n    current.children.push(child);\n    this.stack.push(child);\n  }\n  /**\n   */\n\n\n  closeNode() {\n    this.stack.pop();\n  }\n  /**\n   */\n\n\n  closeAllNodes() {}\n  /**\n   */\n\n\n  finalize() {}\n  /**\n   */\n\n\n  toHTML() {\n    return '';\n  }\n\n}\n\nexport const lowlight = {\n  highlight,\n  highlightAuto,\n  registerLanguage,\n  listLanguages,\n  registerAlias\n};","map":{"version":3,"sources":["E:/projects/localtalk.mobi(back)/pro/toptalk-adminpanel/node_modules/lowlight/lib/core.js"],"names":["high","fault","own","hasOwnProperty","defaultPrefix","highlight","language","value","options","prefix","getLanguage","undefined","configure","__emitter","HastEmitter","classPrefix","result","ignoreIllegals","errorRaised","_emitter","root","data","relevance","highlightAuto","subset","listLanguages","index","type","children","name","current","length","registerLanguage","syntax","registerAlias","alias","map","key","call","registerAliases","languageName","constructor","stack","addText","tail","push","addKeyword","openNode","closeNode","addSublanguage","other","results","tagName","properties","className","split","d","child","pop","closeAllNodes","finalize","toHTML","lowlight"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('highlight.js').HighlightResult} HighlightResult\n * @typedef {import('highlight.js').HLJSOptions} HighlightOptions\n * @typedef {import('highlight.js').LanguageFn} HighlightSyntax\n * @typedef {import('highlight.js').Emitter} HighlightEmitter\n *\n * @typedef {{type: 'element', tagName: 'span', properties: {className: Array.<string>}, children: Array.<LowlightElementSpan|Text>}} LowlightElementSpan\n * @typedef {{type: 'root', data: {language: string, relevance: number}, children: Array.<LowlightElementSpan|Text>}} LowlightRoot\n *\n * @typedef {Object} ExtraAutoOptions\n * @property {Array.<string>} [subset] List of allowed languages; defaults to all registered languages\n *\n * @typedef {Object} LowlightOptions\n * @property {string} [prefix='hljs-'] Class prefix\n *\n * @typedef {LowlightOptions & ExtraAutoOptions} LowlightAutoOptions\n */\n\nimport high from 'highlight.js/lib/core'\nimport {fault} from 'fault'\n\nconst own = {}.hasOwnProperty\n\nconst defaultPrefix = 'hljs-'\n\n/**\n * Parse `value` (code) according to the `language` (name) grammar.\n *\n * @param {string} language Language name\n * @param {string} value Code value\n * @param {LowlightOptions} [options={}] Settings\n * @returns {LowlightRoot}\n */\nfunction highlight(language, value, options = {}) {\n  let prefix = options.prefix\n\n  if (typeof language !== 'string') {\n    throw fault('Expected `string` for name, got `%s`', language)\n  }\n\n  if (!high.getLanguage(language)) {\n    throw fault('Unknown language: `%s` is not registered', language)\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value)\n  }\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix\n  }\n\n  high.configure({__emitter: HastEmitter, classPrefix: prefix})\n  /** @type {HighlightResult & {_emitter: HastEmitter}} */\n  // @ts-ignore our emitter is added.\n  const result = high.highlight(value, {language, ignoreIllegals: true})\n  high.configure({})\n\n  // Highlight.js seems to use this (currently) for broken grammars, so let’s\n  // keep it in there just to be sure.\n  /* c8 ignore next 3 */\n  if (result.errorRaised) {\n    throw result.errorRaised\n  }\n\n  result._emitter.root.data.language = result.language\n  result._emitter.root.data.relevance = result.relevance\n\n  return result._emitter.root\n}\n\n/**\n * Parse `value` (code) by guessing its grammar.\n *\n * @param {string} value Code value\n * @param {LowlightAutoOptions} [options={}] Settings\n * @returns {LowlightRoot}\n */\nfunction highlightAuto(value, options = {}) {\n  const subset = options.subset || high.listLanguages()\n  let prefix = options.prefix\n  let index = -1\n  /** @type {LowlightRoot} */\n  let result = {\n    type: 'root',\n    data: {language: null, relevance: 0},\n    children: []\n  }\n  /** @type {string} */\n  let name\n  /** @type {LowlightRoot} */\n  let current\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value)\n  }\n\n  while (++index < subset.length) {\n    name = subset[index]\n\n    if (!high.getLanguage(name)) continue\n\n    current = highlight(name, value, options)\n\n    if (current.data.relevance > result.data.relevance) result = current\n  }\n\n  return result\n}\n\n/**\n * Register a language.\n *\n * @param {string} language Language name\n * @param {HighlightSyntax} syntax Language syntax\n * @returns {void}\n */\nfunction registerLanguage(language, syntax) {\n  high.registerLanguage(language, syntax)\n}\n\n/**\n * Get a list of all registered languages.\n *\n * @returns {Array.<string>}\n */\nfunction listLanguages() {\n  return high.listLanguages()\n}\n\nconst registerAlias =\n  /**\n   * @type {(\n   *   ((language: string, alias: string|Array.<string>) => void) &\n   *   ((aliases: Object<string, string|Array.<string>>) => void)\n   * )}\n   */\n  (\n    /**\n     * Register more aliases for an already registered language.\n     *\n     * @param {string|Object<string, string|Array.<string>>} language\n     * @param {string|Array.<string>} [alias]\n     * @returns {void}\n     */\n    function (language, alias) {\n      /** @type {Object<string, string|Array.<string>>} */\n      let map\n      /** @type {string} */\n      let key\n\n      if (typeof language === 'string') {\n        map = {}\n        map[language] = alias\n      } else {\n        map = language\n      }\n\n      for (key in map) {\n        if (own.call(map, key)) {\n          high.registerAliases(map[key], {languageName: key})\n        }\n      }\n    }\n  )\n\n/** @type {HighlightEmitter} */\nclass HastEmitter {\n  /**\n   * @param {HighlightOptions} options\n   */\n  constructor(options) {\n    /** @type {HighlightOptions} */\n    this.options = options\n    /** @type {LowlightRoot} */\n    this.root = {\n      type: 'root',\n      data: {language: undefined, relevance: 0},\n      children: []\n    }\n    /** @type {[LowlightRoot, ...LowlightElementSpan[]]} */\n    this.stack = [this.root]\n  }\n\n  /**\n   * @param {string} value\n   */\n  addText(value) {\n    if (value === '') return\n\n    const current = this.stack[this.stack.length - 1]\n    const tail = current.children[current.children.length - 1]\n\n    if (tail && tail.type === 'text') {\n      tail.value += value\n    } else {\n      current.children.push({type: 'text', value})\n    }\n  }\n\n  /**\n   * @param {string} value\n   * @param {string} name\n   */\n  addKeyword(value, name) {\n    this.openNode(name)\n    this.addText(value)\n    this.closeNode()\n  }\n\n  /**\n   * @param {HastEmitter} other\n   * @param {string} name\n   */\n  addSublanguage(other, name) {\n    const current = this.stack[this.stack.length - 1]\n    const results = other.root.children\n\n    if (name) {\n      current.children.push({\n        type: 'element',\n        tagName: 'span',\n        properties: {className: [name]},\n        children: results\n      })\n    } else {\n      current.children.push(...results)\n    }\n  }\n\n  /**\n   * @param {string} name\n   */\n  openNode(name) {\n    const className = name.split('.').map((d) => this.options.classPrefix + d)\n    const current = this.stack[this.stack.length - 1]\n    /** @type {LowlightElementSpan} */\n    const child = {\n      type: 'element',\n      tagName: 'span',\n      properties: {className},\n      children: []\n    }\n\n    current.children.push(child)\n    this.stack.push(child)\n  }\n\n  /**\n   */\n  closeNode() {\n    this.stack.pop()\n  }\n\n  /**\n   */\n  closeAllNodes() {}\n\n  /**\n   */\n  finalize() {}\n\n  /**\n   */\n  toHTML() {\n    return ''\n  }\n}\n\nexport const lowlight = {\n  highlight,\n  highlightAuto,\n  registerLanguage,\n  listLanguages,\n  registerAlias\n}\n"]},"metadata":{},"sourceType":"module"}