{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {import('unist-util-is').Type} Type\n * @typedef {import('unist-util-is').Props} Props\n * @typedef {import('unist-util-is').TestFunctionAnything} TestFunctionAnything\n */\nimport { convert } from 'unist-util-is';\nexport var findAfter =\n/**\n * @param {Parent} parent Parent node\n * @param {Node|number} index Child of `parent`, or it’s index\n * @param {null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>} [test] is-compatible test (such as a type)\n * @returns {Node|null}\n */\nfunction (parent, index, test) {\n  var is = convert(test);\n\n  if (!parent || !parent.type || !parent.children) {\n    throw new Error('Expected parent node');\n  }\n\n  if (typeof index === 'number') {\n    if (index < 0 || index === Number.POSITIVE_INFINITY) {\n      throw new Error('Expected positive finite number as index');\n    }\n  } else {\n    index = parent.children.indexOf(index);\n\n    if (index < 0) {\n      throw new Error('Expected child node or index');\n    }\n  }\n\n  while (++index < parent.children.length) {\n    if (is(parent.children[index], index, parent)) {\n      return parent.children[index];\n    }\n  }\n\n  return null;\n};","map":{"version":3,"sources":["E:/projects/localtalk.mobi(react+node)/pro/toptalk-adminpanel/node_modules/unist-util-find-after/index.js"],"names":["convert","findAfter","parent","index","test","is","type","children","Error","Number","POSITIVE_INFINITY","indexOf","length"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,OAAR,QAAsB,eAAtB;AAEA,OAAO,IAAIC,SAAS;AAQhB;AACJ;AACA;AACA;AACA;AACA;AACI,UAAUC,MAAV,EAAkBC,KAAlB,EAAyBC,IAAzB,EAA+B;AAC7B,MAAIC,EAAE,GAAGL,OAAO,CAACI,IAAD,CAAhB;;AAEA,MAAI,CAACF,MAAD,IAAW,CAACA,MAAM,CAACI,IAAnB,IAA2B,CAACJ,MAAM,CAACK,QAAvC,EAAiD;AAC/C,UAAM,IAAIC,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,MAAI,OAAOL,KAAP,KAAiB,QAArB,EAA+B;AAC7B,QAAIA,KAAK,GAAG,CAAR,IAAaA,KAAK,KAAKM,MAAM,CAACC,iBAAlC,EAAqD;AACnD,YAAM,IAAIF,KAAJ,CAAU,0CAAV,CAAN;AACD;AACF,GAJD,MAIO;AACLL,IAAAA,KAAK,GAAGD,MAAM,CAACK,QAAP,CAAgBI,OAAhB,CAAwBR,KAAxB,CAAR;;AAEA,QAAIA,KAAK,GAAG,CAAZ,EAAe;AACb,YAAM,IAAIK,KAAJ,CAAU,8BAAV,CAAN;AACD;AACF;;AAED,SAAO,EAAEL,KAAF,GAAUD,MAAM,CAACK,QAAP,CAAgBK,MAAjC,EAAyC;AACvC,QAAIP,EAAE,CAACH,MAAM,CAACK,QAAP,CAAgBJ,KAAhB,CAAD,EAAyBA,KAAzB,EAAgCD,MAAhC,CAAN,EAA+C;AAC7C,aAAOA,MAAM,CAACK,QAAP,CAAgBJ,KAAhB,CAAP;AACD;AACF;;AAED,SAAO,IAAP;AACD,CAxCE","sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {import('unist-util-is').Type} Type\n * @typedef {import('unist-util-is').Props} Props\n * @typedef {import('unist-util-is').TestFunctionAnything} TestFunctionAnything\n */\n\nimport {convert} from 'unist-util-is'\n\nexport var findAfter =\n  /**\n   * @type {(\n   *  (<T extends Node>(node: Parent, index: Node|number, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>) => T|null) &\n   *  ((node: Parent, index: Node|number, test?: null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>) => Node|null)\n   * )}\n   */\n  (\n    /**\n     * @param {Parent} parent Parent node\n     * @param {Node|number} index Child of `parent`, or it’s index\n     * @param {null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>} [test] is-compatible test (such as a type)\n     * @returns {Node|null}\n     */\n    function (parent, index, test) {\n      var is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return null\n    }\n  )\n"]},"metadata":{},"sourceType":"module"}