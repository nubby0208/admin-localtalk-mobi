{"ast":null,"code":"/**\n * @typedef {import('hast-util-is-element').TestFunctionAnything} TestFunctionAnything\n * @typedef {import('hast').Parent['children'][number]} HastChild\n * @typedef {import('hast').Text} HastText\n * @typedef {import('hast').Comment} HastComment\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {HastChild|HastRoot} HastNode\n * @typedef {HastRoot|HastElement} HastParent\n *\n * @typedef {'normal'|'pre'|'nowrap'|'pre-wrap'} Whitespace\n * @typedef {boolean} BreakValue\n * @typedef {1|2} BreakNumber\n * @typedef {'\\n'} BreakForce\n * @typedef {BreakValue|BreakNumber} BreakBefore\n * @typedef {BreakValue|BreakNumber|BreakForce} BreakAfter\n *\n * @typedef CollectionOptions\n * @property {Whitespace} whitespace\n * @property {BreakBefore} breakBefore\n * @property {BreakAfter} breakAfter\n */\nimport repeat from 'repeat-string';\nimport { convertElement } from 'hast-util-is-element';\nimport { findAfter } from 'unist-util-find-after';\nvar searchLineFeeds = /\\n/g;\nvar searchTabOrSpaces = /[\\t ]+/g;\nvar br = convertElement('br');\nvar p = convertElement('p');\nvar cell = convertElement(['th', 'td']);\nvar row = convertElement('tr'); // Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\n\nvar notRendered = convertElement([// List from: <https://html.spec.whatwg.org/#hidden-elements>\n'datalist', 'head', 'noembed', 'noframes', 'noscript', // Act as if we support scripting.\n'rp', 'script', 'style', 'template', 'title', // Hidden attribute.\nhidden, // From: <https://html.spec.whatwg.org/#flow-content-3>\nclosedDialog]); // See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n\nvar blockOrCaption = convertElement(['address', // Flow content\n'article', // Sections and headings\n'aside', // Sections and headings\n'blockquote', // Flow content\n'body', // Page\n'caption', // `table-caption`\n'center', // Flow content (legacy)\n'dd', // Lists\n'dialog', // Flow content\n'dir', // Lists (legacy)\n'dl', // Lists\n'dt', // Lists\n'div', // Flow content\n'figure', // Flow content\n'figcaption', // Flow content\n'footer', // Flow content\n'form,', // Flow content\n'h1', // Sections and headings\n'h2', // Sections and headings\n'h3', // Sections and headings\n'h4', // Sections and headings\n'h5', // Sections and headings\n'h6', // Sections and headings\n'header', // Flow content\n'hgroup', // Sections and headings\n'hr', // Flow content\n'html', // Page\n'legend', // Flow content\n'listing', // Flow content (legacy)\n'main', // Flow content\n'menu', // Lists\n'nav', // Sections and headings\n'ol', // Lists\n'p', // Flow content\n'plaintext', // Flow content (legacy)\n'pre', // Flow content\n'section', // Sections and headings\n'ul', // Lists\n'xmp' // Flow content (legacy)\n]);\n/**\n * Implementation of the `innerText` getter:\n * <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n * Note that we act as if `node` is being rendered, and as if we’re a\n * CSS-supporting user agent.\n *\n * @param {HastNode} node\n * @returns {string}\n */\n\nexport function toText(node) {\n  /** @type {Array.<HastChild>} */\n  // @ts-ignore looks like a parent.\n  var children = node.children || [];\n  var block = blockOrCaption(node);\n  var whitespace = inferWhitespace(node, {\n    whitespace: 'normal',\n    breakBefore: false,\n    breakAfter: false\n  });\n  var index = -1;\n  /** @type {Array.<string|BreakNumber>} */\n\n  var results;\n  /** @type {Array.<string>} */\n\n  var result;\n  /** @type {string|BreakNumber} */\n\n  var value;\n  /** @type {number} */\n\n  var count; // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {\n      whitespace,\n      breakBefore: true,\n      breakAfter: true\n    });\n  } // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n  // 2.  Let results be a new empty list.\n\n\n  results = []; // 3.  For each child node node of this element:\n\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat( // @ts-ignore Looks like a parent.\n    innerTextCollection(children[index], node, {\n      whitespace,\n      breakBefore: index ? null : block,\n      breakAfter: index < children.length - 1 ? br(children[index + 1]) : block\n    }));\n  } // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n\n\n  index = -1;\n  result = [];\n\n  while (++index < results.length) {\n    value = results[index];\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value;\n    } else if (value) {\n      if (count) result.push(repeat('\\n', count));\n      count = 0;\n      result.push(value);\n    }\n  } // 7.  Return the concatenation of the string items in results.\n\n\n  return result.join('');\n}\n/**\n * <https://html.spec.whatwg.org/#inner-text-collection-steps>\n *\n * @param {HastNode} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n * @returns {Array.<string|BreakNumber>}\n */\n\nfunction innerTextCollection(node, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, options);\n  }\n\n  if (node.type === 'text') {\n    return [options.whitespace === 'normal' ? collectText(node, options) : collectPreText(node)];\n  }\n\n  return [];\n}\n/**\n * Collect an element.\n *\n * @param {HastElement} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n */\n\n\nfunction collectElement(node, parent, options) {\n  // First we infer the `white-space` property.\n  var whitespace = inferWhitespace(node, options);\n  var children = node.children || [];\n  var index = -1;\n  /** @type {Array.<string|BreakNumber>} */\n\n  var items = [];\n  /** @type {BreakNumber} */\n\n  var prefix;\n  /** @type {BreakNumber|BreakForce} */\n\n  var suffix; // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n\n  if (notRendered(node)) {\n    return items;\n  } // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n  // See `collectText` for step 4.\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n\n\n  if (br(node)) {\n    suffix = '\\n';\n  } // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = '\\n';\n  } // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2;\n    suffix = 2;\n  } // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1;\n    suffix = 1;\n  } // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n\n\n  while (++index < children.length) {\n    items = items.concat(innerTextCollection(children[index], node, {\n      whitespace,\n      breakBefore: index ? undefined : prefix,\n      breakAfter: index < children.length - 1 ? br(children[index + 1]) : suffix\n    }));\n  } // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n\n\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push('\\t');\n  } // Add the pre- and suffix.\n\n\n  if (prefix) items.unshift(prefix);\n  if (suffix) items.push(suffix);\n  return items;\n}\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we don’t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {HastText|HastComment} node\n * @param {CollectionOptions} options\n * @returns {string}\n */\n\n\nfunction collectText(node, options) {\n  var value = String(node.value);\n  /** @type {Array.<string>} */\n\n  var lines = [];\n  /** @type {Array.<string>} */\n\n  var result = [];\n  var start = 0;\n  var index = -1;\n  /** @type {RegExpMatchArray} */\n\n  var match;\n  /** @type {number} */\n\n  var end;\n  /** @type {string} */\n\n  var join;\n\n  while (start < value.length) {\n    searchLineFeeds.lastIndex = start;\n    match = searchLineFeeds.exec(value);\n    end = match ? match.index : value.length;\n    lines.push( // Any sequence of collapsible spaces and tabs immediately preceding or\n    // following a segment break is removed.\n    trimAndCollapseSpacesAndTabs( // [...] ignoring bidi formatting characters (characters with the\n    // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n    // they were not there.\n    value.slice(start, end).replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''), options.breakBefore, options.breakAfter));\n    start = end + 1;\n  } // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n\n\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (lines[index].charCodeAt(lines[index].length - 1) === 0x200b\n    /* ZWSP */\n    || index < lines.length - 1 && lines[index + 1].charCodeAt(0) === 0x200b\n    /* ZWSP */\n    ) {\n      result.push(lines[index]);\n      join = '';\n    } // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (join) result.push(join);\n      result.push(lines[index]);\n      join = ' ';\n    }\n  }\n\n  return result.join('');\n}\n/**\n * @param {HastText|HastComment} node\n * @returns {string}\n */\n\n\nfunction collectPreText(node) {\n  return String(node.value);\n}\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     space—even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     context—is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n * @param {BreakBefore} breakBefore\n * @param {BreakAfter} breakAfter\n * @returns {string}\n */\n\n\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array.<string>} */\n  var result = [];\n  var start = 0;\n  /** @type {RegExpMatchArray} */\n\n  var match;\n  /** @type {number} */\n\n  var end;\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start;\n    match = searchTabOrSpaces.exec(value);\n    end = match ? match.index : value.length; // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n\n    if (!start && !end && match && !breakBefore) {\n      result.push('');\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end));\n    }\n\n    start = match ? end + match[0].length : end;\n  } // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n\n\n  if (start !== end && !breakAfter) {\n    result.push('');\n  }\n\n  return result.join(' ');\n}\n/**\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {HastNode} node\n * @param {CollectionOptions} options\n * @returns {Whitespace}\n */\n\n\nfunction inferWhitespace(node, options) {\n  /** @type {HastProperties} */\n  var props;\n\n  if (node.type === 'element') {\n    props = node.properties || {};\n\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp':\n        return 'pre';\n\n      case 'nobr':\n        return 'nowrap';\n\n      case 'pre':\n        return props.wrap ? 'pre-wrap' : 'pre';\n\n      case 'td':\n      case 'th':\n        return props.noWrap ? 'nowrap' : options.whitespace;\n\n      case 'textarea':\n        return 'pre-wrap';\n\n      default:\n    }\n  }\n\n  return options.whitespace;\n}\n/** @type {TestFunctionAnything} */\n\n\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden);\n}\n/** @type {TestFunctionAnything} */\n\n\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open;\n}","map":{"version":3,"sources":["E:/projects/localtalk.mobi(react+node)/pro/toptalk-adminpanel/node_modules/hast-util-to-text/index.js"],"names":["repeat","convertElement","findAfter","searchLineFeeds","searchTabOrSpaces","br","p","cell","row","notRendered","hidden","closedDialog","blockOrCaption","toText","node","children","block","whitespace","inferWhitespace","breakBefore","breakAfter","index","results","result","value","count","type","collectText","length","concat","innerTextCollection","undefined","push","join","parent","options","collectElement","collectPreText","items","prefix","suffix","unshift","String","lines","start","match","end","lastIndex","exec","trimAndCollapseSpacesAndTabs","slice","replace","charCodeAt","props","properties","tagName","wrap","noWrap","Boolean","open"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('hast-util-is-element').TestFunctionAnything} TestFunctionAnything\n * @typedef {import('hast').Parent['children'][number]} HastChild\n * @typedef {import('hast').Text} HastText\n * @typedef {import('hast').Comment} HastComment\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {HastChild|HastRoot} HastNode\n * @typedef {HastRoot|HastElement} HastParent\n *\n * @typedef {'normal'|'pre'|'nowrap'|'pre-wrap'} Whitespace\n * @typedef {boolean} BreakValue\n * @typedef {1|2} BreakNumber\n * @typedef {'\\n'} BreakForce\n * @typedef {BreakValue|BreakNumber} BreakBefore\n * @typedef {BreakValue|BreakNumber|BreakForce} BreakAfter\n *\n * @typedef CollectionOptions\n * @property {Whitespace} whitespace\n * @property {BreakBefore} breakBefore\n * @property {BreakAfter} breakAfter\n */\n\nimport repeat from 'repeat-string'\nimport {convertElement} from 'hast-util-is-element'\nimport {findAfter} from 'unist-util-find-after'\n\nvar searchLineFeeds = /\\n/g\nvar searchTabOrSpaces = /[\\t ]+/g\n\nvar br = convertElement('br')\nvar p = convertElement('p')\nvar cell = convertElement(['th', 'td'])\nvar row = convertElement('tr')\n\n// Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nvar notRendered = convertElement([\n  // List from: <https://html.spec.whatwg.org/#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'noscript', // Act as if we support scripting.\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nvar blockOrCaption = convertElement([\n  'address', // Flow content\n  'article', // Sections and headings\n  'aside', // Sections and headings\n  'blockquote', // Flow content\n  'body', // Page\n  'caption', // `table-caption`\n  'center', // Flow content (legacy)\n  'dd', // Lists\n  'dialog', // Flow content\n  'dir', // Lists (legacy)\n  'dl', // Lists\n  'dt', // Lists\n  'div', // Flow content\n  'figure', // Flow content\n  'figcaption', // Flow content\n  'footer', // Flow content\n  'form,', // Flow content\n  'h1', // Sections and headings\n  'h2', // Sections and headings\n  'h3', // Sections and headings\n  'h4', // Sections and headings\n  'h5', // Sections and headings\n  'h6', // Sections and headings\n  'header', // Flow content\n  'hgroup', // Sections and headings\n  'hr', // Flow content\n  'html', // Page\n  'legend', // Flow content\n  'listing', // Flow content (legacy)\n  'main', // Flow content\n  'menu', // Lists\n  'nav', // Sections and headings\n  'ol', // Lists\n  'p', // Flow content\n  'plaintext', // Flow content (legacy)\n  'pre', // Flow content\n  'section', // Sections and headings\n  'ul', // Lists\n  'xmp' // Flow content (legacy)\n])\n\n/**\n * Implementation of the `innerText` getter:\n * <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n * Note that we act as if `node` is being rendered, and as if we’re a\n * CSS-supporting user agent.\n *\n * @param {HastNode} node\n * @returns {string}\n */\nexport function toText(node) {\n  /** @type {Array.<HastChild>} */\n  // @ts-ignore looks like a parent.\n  var children = node.children || []\n  var block = blockOrCaption(node)\n  var whitespace = inferWhitespace(node, {\n    whitespace: 'normal',\n    breakBefore: false,\n    breakAfter: false\n  })\n  var index = -1\n  /** @type {Array.<string|BreakNumber>} */\n  var results\n  /** @type {Array.<string>} */\n  var result\n  /** @type {string|BreakNumber} */\n  var value\n  /** @type {number} */\n  var count\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {whitespace, breakBefore: true, breakAfter: true})\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  results = []\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat(\n      // @ts-ignore Looks like a parent.\n      innerTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? null : block,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : block\n      })\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  index = -1\n  result = []\n\n  while (++index < results.length) {\n    value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count) result.push(repeat('\\n', count))\n      count = 0\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n/**\n * <https://html.spec.whatwg.org/#inner-text-collection-steps>\n *\n * @param {HastNode} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n * @returns {Array.<string|BreakNumber>}\n */\nfunction innerTextCollection(node, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, options)\n  }\n\n  if (node.type === 'text') {\n    return [\n      options.whitespace === 'normal'\n        ? collectText(node, options)\n        : collectPreText(node)\n    ]\n  }\n\n  return []\n}\n\n/**\n * Collect an element.\n *\n * @param {HastElement} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n */\nfunction collectElement(node, parent, options) {\n  // First we infer the `white-space` property.\n  var whitespace = inferWhitespace(node, options)\n  var children = node.children || []\n  var index = -1\n  /** @type {Array.<string|BreakNumber>} */\n  var items = []\n  /** @type {BreakNumber} */\n  var prefix\n  /** @type {BreakNumber|BreakForce} */\n  var suffix\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      innerTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? undefined : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we don’t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {HastText|HastComment} node\n * @param {CollectionOptions} options\n * @returns {string}\n */\nfunction collectText(node, options) {\n  var value = String(node.value)\n  /** @type {Array.<string>} */\n  var lines = []\n  /** @type {Array.<string>} */\n  var result = []\n  var start = 0\n  var index = -1\n  /** @type {RegExpMatchArray} */\n  var match\n  /** @type {number} */\n  var end\n  /** @type {string} */\n  var join\n\n  while (start < value.length) {\n    searchLineFeeds.lastIndex = start\n    match = searchLineFeeds.exec(value)\n    end = match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // [...] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\n        options.breakBefore,\n        options.breakAfter\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x200b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x200b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = ''\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (join) result.push(join)\n      result.push(lines[index])\n      join = ' '\n    }\n  }\n\n  return result.join('')\n}\n\n/**\n * @param {HastText|HastComment} node\n * @returns {string}\n */\nfunction collectPreText(node) {\n  return String(node.value)\n}\n\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     space—even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     context—is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n * @param {BreakBefore} breakBefore\n * @param {BreakAfter} breakAfter\n * @returns {string}\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array.<string>} */\n  var result = []\n  var start = 0\n  /** @type {RegExpMatchArray} */\n  var match\n  /** @type {number} */\n  var end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    match = searchTabOrSpaces.exec(value)\n    end = match ? match.index : value.length\n\n    // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n/**\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {HastNode} node\n * @param {CollectionOptions} options\n * @returns {Whitespace}\n */\nfunction inferWhitespace(node, options) {\n  /** @type {HastProperties} */\n  var props\n\n  if (node.type === 'element') {\n    props = node.properties || {}\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp':\n        return 'pre'\n      case 'nobr':\n        return 'nowrap'\n      case 'pre':\n        return props.wrap ? 'pre-wrap' : 'pre'\n      case 'td':\n      case 'th':\n        return props.noWrap ? 'nowrap' : options.whitespace\n      case 'textarea':\n        return 'pre-wrap'\n      default:\n    }\n  }\n\n  return options.whitespace\n}\n\n/** @type {TestFunctionAnything} */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden)\n}\n\n/** @type {TestFunctionAnything} */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n"]},"metadata":{},"sourceType":"module"}